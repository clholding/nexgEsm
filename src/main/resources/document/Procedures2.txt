***** getDeviceGroupByLogin *****
CREATE DEFINER=`sesm`@`%` PROCEDURE `getDeviceGroupByLogin`(IN login VARCHAR(128), IN mode INT)
BEGIN
  -- 로그인한 관리자가 관리하는 전체 그룹(하위 그룹 포함)에 속한 장비 그룹의 장비 type 별 장애 장비 개수 및 그룹에 속한 장비 개수 조회
  DECLARE current_lv int UNSIGNED;
  DECLARE current_lv2 int UNSIGNED;
  DECLARE parent_ids varchar(10000);
  DECLARE child_ids varchar(10000);
  DECLARE cnt int DEFAULT 0;
  DECLARE before_cnt int DEFAULT 0;
  DECLARE done INT DEFAULT 0;
  DECLARE id_var INT DEFAULT 0;
  DECLARE group_id_var INT DEFAULT 0;
  DECLARE total_count INT DEFAULT 0;
  DECLARE fail_count INT DEFAULT 0;
  DECLARE top_id_var INT DEFAULT 0;
  DECLARE my_cursor CURSOR FOR SELECT id, group_id  FROM _temp_buffer2 ORDER BY lv DESC;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

  SET SESSION sql_log_bin = OFF;
  SET SESSION tx_isolation = 'READ-COMMITTED';
  SET @_current_lv := 1;

  -- login 관리자가 관리하는 장비 그룹 조회
  drop table if exists _temp_buffer;
  CREATE TEMPORARY TABLE IF NOT EXISTS _temp_buffer (
    id int(11),
    name varchar(255),
    group_id int(11),
    total int(11),
    fail int(11),
    lv int,
    INDEX ix_lv (lv)
  ) ENGINE = MEMORY;

  INSERT INTO _temp_buffer SELECT dg.id, dg.name, dg.group_id, 0, 0, @_current_lv AS lv
    FROM user_dgroup ud, device_group dg, user u WHERE u.id = ud.user_id AND ud.device_group_id = dg.id AND u.login = login GROUP BY dg.id;

recursion:
  REPEAT
    SET before_cnt = cnt;
    SELECT GROUP_CONCAT(_temp_buffer.id), COUNT(*) INTO parent_ids, cnt FROM _temp_buffer WHERE lv = @_current_lv;

    IF cnt = 0 THEN
      LEAVE recursion;
    END IF;

    SET @query = CONCAT("INSERT INTO _temp_buffer
            SELECT dg.id, dg.name, dg.group_id, 0, 0, (@_current_lv + 1) AS lv
            FROM device_group dg WHERE (dg.id <> dg.group_id) AND dg.group_id IN (", parent_ids, ")");
    PREPARE stmt3 FROM @query;
    EXECUTE stmt3;

    SET @_current_lv = @_current_lv + 1;
  UNTIL 0 END REPEAT;

  drop table if exists _temp_buffer2;
  create temporary table _temp_buffer2 engine=memory select * from _temp_buffer;

  OPEN my_cursor;
  read_loop: LOOP
    FETCH my_cursor INTO id_var, group_id_var;
    IF done THEN
      LEAVE read_loop;
    END IF;

    -- 장비 그룹에 속한 장비 개수 및 장애 장비 개수 조회하여 _temp_buffer에 업데이트
    SELECT count(*) INTO total_count FROM device d LEFT JOIN product p ON p.id = d.product_id WHERE FIND_IN_SET(d.group_id, id_var) AND d.candidate = 0 AND CASE mode WHEN 0 THEN 1 = 1 ELSE p.type = mode END;
    SELECT count(*) INTO fail_count FROM device d LEFT JOIN product p ON p.id = d.product_id, device_status ds WHERE FIND_IN_SET(d.group_id, id_var) AND d.id = ds.device_id AND ds.status <= 0 AND d.candidate = 0 AND CASE mode WHEN 0 THEN 1 = 1 ELSE  p.type = mode END;

    UPDATE _temp_buffer SET total=total+total_count, fail=fail+fail_count WHERE id = id_var;

    SELECT total INTO @child_total FROM _temp_buffer WHERE id = id_var;
    SELECT fail INTO @child_fail FROM _temp_buffer WHERE id = id_var;

    -- 장비 개수 및 장애 장비 개수를 상위 그룹에도 업데이트
    UPDATE _temp_buffer SET total=total+@child_total, fail=fail+@child_fail WHERE id = group_id_var AND id_var <> group_id;

  END LOOP;
  CLOSE my_cursor;

  # status 1 : 정상, 0 : 장애
  SELECT device_group.id, device_group.name, device_group.group_id, case _temp_buffer.fail
      when 0 then 1
      else 0
  end as state, _temp_buffer.total, _temp_buffer.fail, device_group.code1, device_group.code2 FROM device_group, _temp_buffer WHERE _temp_buffer.id = device_group.id;

  TRUNCATE TABLE _temp_buffer2;
  TRUNCATE TABLE _temp_buffer;
  SET SESSION sql_log_bin = ON;
  SET SESSION tx_isolation = 'REPEATABLE-READ';

END


***** getDeviceListByLogin *****
CREATE DEFINER=`sesm`@`%` PROCEDURE `getDeviceListByLogin`(IN login VARCHAR(128),
  IN type INT,  -- 1 : 간략 정보, 2: 상세 정보
  IN mode INT)
BEGIN
  -- 관리자가 관리하는 전체 그룹(하위 그룹 포함)에 포함하는 장비의  정보를 조회
  DECLARE current_lv int UNSIGNED;
  DECLARE parent_ids varchar(10000);
  DECLARE child_ids varchar(10000);
  DECLARE cnt int DEFAULT 0;
  DECLARE before_cnt int DEFAULT 0;

  SET SESSION sql_log_bin = OFF;
  SET SESSION tx_isolation = 'READ-COMMITTED';
  SET @_current_lv := 1;

  drop table if exists _temp_buffer;
  CREATE TEMPORARY TABLE IF NOT EXISTS _temp_buffer (
    id int(11),
    name varchar(255),
    group_id int(11),
    lv int,
    INDEX ix_lv (lv)
  ) ENGINE = MEMORY;

  INSERT INTO _temp_buffer SELECT dg.id, dg.name, dg.group_id, @_current_lv AS lv
    FROM user_dgroup ud, device_group dg, user u WHERE u.id = ud.user_id AND ud.device_group_id = dg.id AND u.login = login GROUP BY dg.id;

recursion:
  REPEAT
    SET before_cnt = cnt;
    SELECT GROUP_CONCAT(_temp_buffer.id), COUNT(*) INTO parent_ids, cnt FROM _temp_buffer WHERE lv = @_current_lv;

    IF cnt = 0 THEN
      LEAVE recursion;
    END IF;

    SET @query = CONCAT("INSERT INTO _temp_buffer
            SELECT dg.id, dg.name, dg.group_id, (@_current_lv + 1) AS lv
            FROM device_group dg WHERE (dg.id <> dg.group_id) AND dg.group_id IN (", parent_ids, ")");
    PREPARE stmt3 FROM @query;
    EXECUTE stmt3;

    SET @_current_lv = @_current_lv + 1;
  UNTIL 0 END REPEAT;

  SELECT GROUP_CONCAT(DISTINCT _temp_buffer.id) INTO child_ids FROM _temp_buffer;

  TRUNCATE TABLE _temp_buffer;
  SET SESSION sql_log_bin = ON;
  SET SESSION tx_isolation = 'REPEATABLE-READ';

  IF child_ids IS NULL THEN
    SELECT 0, 0;
  ELSE
    IF (type = 1) THEN
      SET @query = CONCAT("SELECT id, name, group_id, active FROM device WHERE group_id IN (", child_ids, ") AND candidate = 0");
      PREPARE stmt FROM @query;
      EXECUTE stmt;
      DEALLOCATE PREPARE stmt;
    ELSE
      SET @query = CONCAT("SELECT d.id, d.name as text, d.group_id, 'true' as leaf, d.ip, p.name as model, di.os, di.serial, d.active, d.cdate, ds.status as state, d.log, d.alarm, di.code1, di.code2,
        MIN(ii.status) as intfs,
        MIN(CASE WHEN eix.status = '' OR eix.status IS NULL THEN NULL ELSE CASE eix.status LIKE 'down%' WHEN 1 THEN 0 ELSE 1 END END) as eixs,
        MIN(CASE vrrp.status WHEN 'master' THEN 1  WHEN 'backup' THEN 0 ELSE NULL END) as vrrps,
        MIN(ts.status) as tracks,
        GROUP_CONCAT(DISTINCT ii.name) as intlist, p.`type`
        FROM device as d, device_info as di, product as p, device_status as ds
        LEFT JOIN int_info ii ON (ii.device_id = ds.device_id AND ii.active = 1)
        LEFT JOIN eix_status eix ON (ds.device_id = eix.device_id)
        LEFT JOIN vrrp_status vrrp ON (ds.device_id = vrrp.device_id)
        LEFT JOIN track_status ts ON (ds.device_id = ts.device_id)
        WHERE d.candidate = 0 AND d.id = di.device_id AND d.id = ds.device_id AND d.product_id = p.id AND group_id IN (", child_ids, ") AND CASE ", mode, " WHEN 0 THEN 1 = 1 ELSE p.type = ", mode, " END GROUP BY d.id");
      PREPARE stmt FROM @query;
      EXECUTE stmt;
      DEALLOCATE PREPARE stmt;
    END IF;
  END IF;
END


***** searchDeviceInfoList *****
CREATE DEFINER=`sesm`@`%` PROCEDURE `searchDeviceInfoList`(
  IN ids VARCHAR(2048),
  IN product_id INT,
  IN dname VARCHAR(128),
  IN gname VARCHAR(128),
  IN ip VARCHAR(32),
  IN serial VARCHAR(255),
  IN os VARCHAR(64),
  IN agent VARCHAR(128),
  IN `desc` VARCHAR(255),
  IN company VARCHAR(255),
  IN phone1 VARCHAR(255),
  IN fax VARCHAR(255),
  IN zip VARCHAR(255),
  IN address VARCHAR(255),
  IN customer VARCHAR(255),
  IN phone2 VARCHAR(255),
  IN email VARCHAR(255),
  IN skip VARCHAR(8),
  IN limits VARCHAR(8))
BEGIN
  -- 장비 조건 검색
  DECLARE current_lv INT UNSIGNED;
  DECLARE parent_ids VARCHAR(10000);
  DECLARE child_ids VARCHAR(10000);
  DECLARE strWhere varchar(1024);
  DECLARE strLimit VARCHAR(32);
  DECLARE cnt INT DEFAULT 0;
  DECLARE before_cnt INT DEFAULT 0;


  SET SESSION sql_log_bin=OFF;
  SET SESSION tx_isolation='READ-COMMITTED';
  SET @_current_lv := 1;
  SET strWhere = '';
  SET strLimit = '';
  SET child_ids = '';

  # gname 조건문 생성
  IF gname IS NOT NULL AND gname != "" THEN
    CREATE TEMPORARY TABLE IF NOT EXISTS _temp_buffer(
      id int(11),
      name varchar(255),
      group_id int(11),
      lv int,
      INDEX ix_lv(lv)
      ) ENGINE=MEMORY;

      SET @query = CONCAT("INSERT INTO _temp_buffer
          SELECT dg.id, dg.name, dg.group_id, ? AS lv
          FROM device_group dg WHERE dg.name like '%", gname, "%'");
      PREPARE stmt3 FROM @query;
      EXECUTE stmt3 USING @_current_lv;

      recursion: REPEAT
      SET before_cnt = cnt;
      SELECT GROUP_CONCAT(_temp_buffer.id), COUNT(*) INTO parent_ids, cnt
      FROM _temp_buffer WHERE lv=@_current_lv;

      IF cnt = before_cnt THEN
        LEAVE recursion;
      ELSEIF cnt = 0 THEN
        LEAVE recursion;
      END IF;

      SET @query = CONCAT("INSERT INTO _temp_buffer
        SELECT dg.id, dg.name, dg.group_id, (? + 1) AS lv
        FROM device_group dg WHERE dg.group_id IN (", parent_ids , ")");
      PREPARE stmt3 FROM @query;
      EXECUTE stmt3 USING @_current_lv;

      SET @_current_lv = @_current_lv + 1;
    UNTIL 0 END REPEAT;

    SELECT GROUP_CONCAT(DISTINCT _temp_buffer.id) INTO child_ids FROM _temp_buffer;

    TRUNCATE TABLE _temp_buffer;
    SET SESSION sql_log_bin=ON;
    SET SESSION tx_isolation='REPEATABLE-READ';

    IF child_ids IS NOT NULL THEN
      SET strWhere = CONCAT(strWhere, " AND d.group_id IN (", child_ids, ")");
    ELSE
      #그룹명의 검색조건으로 결과가 없는 경우.
      SET strWhere = " AND 1 != 1";
    END IF;
  END IF;

  # dname 조건문 생성
  IF dname IS NOT NULL AND dname != "" THEN
    SET strWhere = CONCAT(strWhere, " AND d.name like '%", dname, "%'");
  END IF;

  # product_id 조건문 생성
  IF product_id IS NOT NULL THEN
    SET strWhere = CONCAT(strWhere, " AND d.product_id = ", product_id);
  END IF;

  # ip 조건문 생성
  IF ip IS NOT NULL AND ip != "" THEN
    SET strWhere = CONCAT(strWhere, " AND d.ip like '%", ip, "%'");
  END IF;

  # serial 조건문 생성
  IF serial IS NOT NULL AND serial != "" THEN
    SET strWhere = CONCAT(strWhere, " AND di.serial like '%", serial, "%'");
  END IF;

  # os 조건문 생성
  IF os IS NOT NULL AND os != "" THEN
    SET strWhere = CONCAT(strWhere, " AND di.os like '%", os, "%'");
  END IF;

  # agent 조건문 생성
  IF agent IS NOT NULL AND agent != "" THEN
    SET strWhere = CONCAT(strWhere, " AND di.agent like '%", agent, "%'");
  END IF;

  # `desc` 조건문 생성
  IF `desc` IS NOT NULL AND `desc` != "" THEN
    SET strWhere = CONCAT(strWhere, " AND d.`desc` like '%", `desc`, "%'");
  END IF;

  # company 조건문 생성
  IF company IS NOT NULL AND company != "" THEN
    SET strWhere = CONCAT(strWhere, " AND di.company like '%", company, "%'");
  END IF;


  # phone1 조건문 생성
  IF phone1 IS NOT NULL AND phone1 != "" THEN
    SET strWhere = CONCAT(strWhere, " AND di.phone1 like '%", phone1, "%'");
  END IF;

  # fax 조건문 생성
  IF fax IS NOT NULL AND fax != "" THEN
    SET strWhere = CONCAT(strWhere, " AND di.fax like '%", fax, "%'");
  END IF;

  # zip 조건문 생성
  IF zip IS NOT NULL AND zip != "" THEN
    SET strWhere = CONCAT(strWhere, " AND di.zip like '%", zip, "%'");
  END IF;

  # address 조건문 생성
  IF address IS NOT NULL AND address != "" THEN
    SET strWhere = CONCAT(strWhere, " AND di.address like '%", address, "%'");
  END IF;

  # customer 조건문 생성
  IF customer IS NOT NULL AND customer != "" THEN
    SET strWhere = CONCAT(strWhere, " AND di.customer like '%", customer, "%'");
  END IF;

  # phone2 조건문 생성
  IF phone2 IS NOT NULL AND phone2 != "" THEN
    SET strWhere = CONCAT(strWhere, " AND di.phone2 like '%", phone2, "%'");
  END IF;

  # email 조건문 생성
  IF email IS NOT NULL AND email != "" THEN
    SET strWhere = CONCAT(strWhere, " AND di.email like '%", email, "%'");
  END IF;

  IF (NULLIF(skip, '') IS NOT NULL) AND (NULLIF(limits, '') IS NOT NULL) THEN
    SET strLimit = CONCAT(strLimit, ' LIMIT ', skip, ',', limits);
  END IF;

  set @query = CONCAT("SELECT COUNT(*) INTO @Total
    FROM device_info di, device_group dg, product p, device d, snmp_info si
    WHERE d.id IN (", ids, ") AND di.device_id = d.id AND dg.id = d.group_id AND p.id = d.product_id AND d.id = si.device_id ", strWhere);

  PREPARE stmt FROM @query;
  EXECUTE stmt;
  DEALLOCATE PREPARE stmt;

  set @query = CONCAT("SELECT d.id, d.name as dn, d.`desc`, d.ip, p.id as product_id, dg.id as pGroupID, dg.name as gn,
    di.serial, di.os, di.agent, di.hostname, di.company, di.customer, di.email, di.zip,
    di.address, di.phone1, di.phone2, di.fax, di.`mid`, di.mpass, @Total
    FROM device_info di, device_group dg, product p, device d, snmp_info si
    WHERE d.id IN (", ids, ") AND di.device_id = d.id AND dg.id = d.group_id AND p.id = d.product_id AND d.id = si.device_id ", strWhere, strLimit);

  PREPARE stmt FROM @query;
  EXECUTE stmt;
  DEALLOCATE PREPARE stmt;

END


***** getAlarmDeviceGroupOfLogin *****
CREATE DEFINER=`sesm`@`%` PROCEDURE `getAlarmDeviceGroupOfLogin`(IN login VARCHAR(128))
BEGIN
  -- login 관리자가 관리하는 장비 그룹의 정보 조회
  DECLARE current_lv int UNSIGNED;
  DECLARE current_lv2 int UNSIGNED;
  DECLARE parent_ids varchar(10000);
  DECLARE child_ids varchar(10000);
  DECLARE cnt int DEFAULT 0;
  DECLARE before_cnt int DEFAULT 0;
  DECLARE done INT DEFAULT 0;
  DECLARE id_var INT DEFAULT 0;
  DECLARE group_id_var INT DEFAULT 0;
  DECLARE total_count INT DEFAULT 0;
  DECLARE fail_count INT DEFAULT 0;
  DECLARE top_id_var INT DEFAULT 0;
  DECLARE my_cursor CURSOR FOR SELECT id, group_id  FROM _temp_buffer2 ORDER BY lv DESC;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

  SET SESSION sql_log_bin = OFF;
  SET SESSION tx_isolation = 'READ-COMMITTED';
  SET @_current_lv := 1;

  -- login 관리자가 관리하는 장비 그룹 조회 - begin
  drop table if exists _temp_buffer;
  CREATE TEMPORARY TABLE IF NOT EXISTS _temp_buffer (
    id int(11),
    name varchar(255),
    group_id int(11),
    total int(11),
    fail int(11),
    lv int,
    INDEX ix_lv (lv)
    ) ENGINE = MEMORY;

    INSERT INTO _temp_buffer SELECT dg.id, dg.name, dg.group_id, 0, 0, @_current_lv AS lv
    FROM user_dgroup ud, device_group dg, user u WHERE u.id = ud.user_id AND ud.device_group_id = dg.id AND u.login = login GROUP BY dg.id;

    recursion:
    REPEAT
    SET before_cnt = cnt;
    SELECT GROUP_CONCAT(_temp_buffer.id), COUNT(*) INTO parent_ids, cnt FROM _temp_buffer WHERE lv = @_current_lv;

    IF cnt = 0 THEN
      LEAVE recursion;
    END IF;

    SET @query = CONCAT("INSERT INTO _temp_buffer
      SELECT dg.id, dg.name, dg.group_id, 0, 0, (@_current_lv + 1) AS lv
      FROM device_group dg WHERE (dg.id <> dg.group_id) AND dg.group_id IN (", parent_ids, ")");
    PREPARE stmt3 FROM @query;
    EXECUTE stmt3;

    SET @_current_lv = @_current_lv + 1;
  UNTIL 0 END REPEAT;
  -- login 관리자가 관리하는 장비 그룹 조회 - end

  drop table if exists _temp_buffer2;
  -- 같은 table에서 select, update 동시에 처리 불가능하여 같은 데이터를 가진 _temp_buffer2 생성
  create temporary table _temp_buffer2 engine=memory select * from _temp_buffer;

  -- 장비 그룹의 하위 그룹에 포함된 장애 장비 개수와 전체 장비 개수를 구함.
  OPEN my_cursor;
  read_loop: LOOP
    FETCH my_cursor INTO id_var, group_id_var;
    IF done THEN
      LEAVE read_loop;
    END IF;

    -- id_var 장비 그룹에 속한 FW, UTM 장비 중 장애 장비 개수와 전체 장비 개수 조회
    SELECT count(*) INTO total_count FROM device d LEFT JOIN product p ON p.id = d.product_id WHERE FIND_IN_SET(d.group_id, id_var) AND d.candidate = 0 AND p.type IN (1,2);
    SELECT count(*) INTO fail_count FROM device d LEFT JOIN product p ON p.id = d.product_id, device_status ds WHERE FIND_IN_SET(d.group_id, id_var) AND d.id = ds.device_id AND ds.status <= 0 AND d.candidate = 0 AND p.type IN (1,2);

    -- id_var 장비 그룹에 속한 FW, UTM 장비 중 장애 장비 개수와 전체 장비 개수 _temp_buffer 테이블에 업데이트
    UPDATE _temp_buffer SET total=total+total_count, fail=fail+fail_count WHERE id = id_var;

    SELECT total INTO @child_total FROM _temp_buffer WHERE id = id_var;
    SELECT fail INTO @child_fail FROM _temp_buffer WHERE id = id_var;

    -- id_var 장비 그룹의 상위그룹에 FW, UTM 장비 중 장애 장비 개수와 전체 장비 개수를 업데이트
    -- 장비 그룹의 하위 그룹에 포함된 장애 장비 개수와 전체 장비 개수를 구해야함.
    UPDATE _temp_buffer SET total=total+@child_total, fail=fail+@child_fail WHERE id = group_id_var AND id_var <> group_id;

  END LOOP;
  CLOSE my_cursor;

  SELECT device_group.id, device_group.name, device_group.group_id, case _temp_buffer.fail
  when 0 then 1
  else 0
  end as state FROM device_group, _temp_buffer WHERE _temp_buffer.id = device_group.id;

  TRUNCATE TABLE _temp_buffer2;
  TRUNCATE TABLE _temp_buffer;
  SET SESSION sql_log_bin = ON;
  SET SESSION tx_isolation = 'REPEATABLE-READ';

END


***** getAlarmDeviceListOfLogin *****
CREATE DEFINER=`sesm`@`%` PROCEDURE `getAlarmDeviceListOfLogin`(
  IN login VARCHAR(128),
  IN type INT)
BEGIN
  -- login 관리자가 관리하는 그룹에 포함된 설정 정보 조회
  DECLARE current_lv int UNSIGNED;
  DECLARE parent_ids varchar(10000);
  DECLARE child_ids varchar(10000);
  DECLARE cnt int DEFAULT 0;
  DECLARE before_cnt int DEFAULT 0;

  SET SESSION sql_log_bin = OFF;
  SET SESSION tx_isolation = 'READ-COMMITTED';
  SET @_current_lv := 1;

  -- login 관리자가 관리하는 장비 그룹 조회 - begin
  drop table if exists _temp_buffer;
  CREATE TEMPORARY TABLE IF NOT EXISTS _temp_buffer (
    id int(11),
    name varchar(255),
    group_id int(11),
    lv int,
    INDEX ix_lv (lv)
    ) ENGINE = MEMORY;

    INSERT INTO _temp_buffer SELECT dg.id, dg.name, dg.group_id, @_current_lv AS lv
    FROM user_dgroup ud, device_group dg, user u WHERE u.id = ud.user_id AND ud.device_group_id = dg.id AND u.login = login GROUP BY dg.id;

recursion:
  REPEAT
    SET before_cnt = cnt;
    SELECT GROUP_CONCAT(_temp_buffer.id), COUNT(*) INTO parent_ids, cnt FROM _temp_buffer WHERE lv = @_current_lv;

    IF cnt = 0 THEN
      LEAVE recursion;
    END IF;

    SET @query = CONCAT("INSERT INTO _temp_buffer
      SELECT dg.id, dg.name, dg.group_id, (@_current_lv + 1) AS lv
      FROM device_group dg WHERE (dg.id <> dg.group_id) AND dg.group_id IN (", parent_ids, ")");
    PREPARE stmt3 FROM @query;
    EXECUTE stmt3;

    SET @_current_lv = @_current_lv + 1;
  UNTIL 0 END REPEAT;
  -- login 관리자가 관리하는 장비 그룹 조회 - end

  SELECT GROUP_CONCAT(DISTINCT _temp_buffer.id) INTO child_ids FROM _temp_buffer;

  TRUNCATE TABLE _temp_buffer;
  SET SESSION sql_log_bin = ON;
  SET SESSION tx_isolation = 'REPEATABLE-READ';

  IF child_ids IS NULL THEN
    SELECT 0, 0;
  ELSE
    IF (type = 1) THEN
      SET @query = CONCAT("SELECT d.id, d.name, d.group_id FROM device d, product p WHERE d.group_id IN (", child_ids, ") AND d.candidate = 0 AND d.product_id = p.id AND p.type IN (1,2)");
      PREPARE stmt FROM @query;
      EXECUTE stmt;
      DEALLOCATE PREPARE stmt;
    ELSE
      SET @query = CONCAT("SELECT d.id, d.name as text, d.group_id, 'true' as leaf, d.ip, p.name, di.os, di.serial, d.active, d.cdate, ds.status, d.log, d.alarm, di.code1, di.code2,
        MIN(ii.status) as intfs,
        MIN(CASE WHEN eix.status = '' OR eix.status IS NULL THEN NULL ELSE CASE eix.status LIKE 'down%' WHEN 1 THEN 0 ELSE 1 END END) as eixs,
        MIN(CASE vrrp.status WHEN 'master' THEN 1  WHEN 'backup' THEN 0 ELSE NULL END) as vrrps,
        MIN(ts.status) as tracks,
        GROUP_CONCAT(DISTINCT ii.name) as intlist
        FROM device as d, device_info as di, product as p, device_status as ds
        LEFT JOIN int_info ii ON (ii.device_id = ds.device_id AND ii.active = 1)
        LEFT JOIN eix_status eix ON (ds.device_id = eix.device_id)
        LEFT JOIN vrrp_status vrrp ON (ds.device_id = vrrp.device_id)
        LEFT JOIN track_status ts ON (ds.device_id = ts.device_id)
        WHERE d.candidate = 0 AND d.id = di.device_id AND d.id = ds.device_id AND d.product_id = p.id AND group_id IN (", child_ids, ") AND  p.type IN (1,2) GROUP BY d.id");
      PREPARE stmt FROM @query;
      EXECUTE stmt;
      DEALLOCATE PREPARE stmt;
    END IF;
  END IF;

END


***** getCandidateList *****
CREATE DEFINER=`sesm`@`%` PROCEDURE `getCandidateList`(IN type INT)
BEGIN
  -- 등록 대기 장비 리스트 조회 (100개 제한)
  IF type IS NULL THEN
    SELECT d.id, d.ip, di.hostname, di.os, di.serial, d.product_id as model, di.license, d.name, p.name as productname FROM device as d, device_info as di, product as p
      WHERE d.id = di.device_id AND d.product_id = p.id AND d.candidate = 1
      LIMIT 100;
  ELSE
    SELECT d.id, d.ip, di.hostname, di.os, di.serial, d.product_id as model, di.license, d.name, p.name as productname FROM device as d, device_info as di, product as p
      WHERE d.id = di.device_id AND d.product_id = p.id AND d.candidate = 1 AND p.type = type
      LIMIT 100;
  END IF;
END


***** overwriteDeviceInfo *****
CREATE DEFINER=`sesm`@`%` PROCEDURE `overwriteDeviceInfo`(
  IN id INT, IN overwrited_id INT, IN name VARCHAR(128),
  IN `desc` VARCHAR(255), IN ip VARCHAR(32),
  IN active INT, IN log INT, IN alarm INT,
  IN serial VARCHAR(255), IN company VARCHAR(255), IN customer VARCHAR(255),
  IN email VARCHAR(255), IN zip VARCHAR(255),
  IN address VARCHAR(255), IN phone1 VARCHAR(255),
  IN phone2 VARCHAR(255), IN fax VARCHAR(255),
  IN `mid` VARCHAR(255), IN mpass VARCHAR(255),
  IN gid INT, IN product_id INT,
  IN use_inherit INT,
  IN version VARCHAR(32), IN community VARCHAR(128),
  IN `level` VARCHAR(32), IN `user` VARCHAR(128),
  IN authprot VARCHAR(128), IN authpass VARCHAR(128),
  IN privprot VARCHAR(32), IN privpass VARCHAR(128),
  IN memo1 VARCHAR(255), IN memo2 VARCHAR(255),
  IN code1 VARCHAR(32), IN code2 VARCHAR(32)
)
BEGIN
  -- 장비 교체 (overwrite_id 장비의 설정 정보와 id 를 그대로 사용하고 신규 장비(id)의 라이센스, ip를 사용한다.)
  DECLARE cur_state INT DEFAULT '0';
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET cur_state = 1;
  DECLARE CONTINUE HANDLER FOR SQLWARNING  SET cur_state = 1;
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET cur_state = 1;

  START TRANSACTION;

  SET_DEVICEINFO:
  BEGIN
    -- overwrited id : 교체대상 장비
    -- id : 새로운 장비

    -- 교체대상 장비의 serial 이나 새로운 장비의 serial 이 현재 입력된 serial 과는 동일할 수 있지만, 다른 장비의 serial 과는 동일할 수 없다.
    -- 교체대상 장비의 name 이나 새로운 장비의 name 이 현재 입력된 name 과는 동일할 수 있지만, 다른 장비의 name 과는 동일할 수 없다.

    DELETE FROM device WHERE device.id = id;
    SET cur_state = 0;

    SELECT di.device_id INTO @id_var FROM device_info di WHERE di.serial = serial;

    SET cur_state = 0;
    -- 동일한 serial 이 있는 경우
    IF @id_var IS NOT NULL THEN
      #교체하려는 장비 serial 이 아닌 경우
      IF @id_var != overwrited_id AND @id_var != id THEN
        SELECT 0 as col, 0 as col2;
        ROLLBACK;
        LEAVE SET_DEVICEINFO;
      END IF;
    END IF;

    SET cur_state = 0;
    -- 동일한 장비 이름이 있는지 확인
    SELECT d.id INTO @id_var FROM device d WHERE d.name = name;

    -- 동일한 장비 이름이 있는 경우
    IF @id_var != overwrited_id THEN
      SELECT 0 as col, id as col2;
      ROLLBACK;
      LEAVE SET_DEVICEINFO;
    END IF;

    SET cur_state = 0;
    UPDATE device SET device.name = name, device.desc=`desc`, device.ip = ip, device.active = active, device.log = log,
    device.alarm = alarm, device.product_id = product_id, device.group_id = gid WHERE device.id = overwrited_id;

    IF cur_state THEN
      ROLLBACK;
      SELECT 0 as col, overwrited_id as col2;
    ELSE
      UPDATE device_info SET
      device_info.serial = serial, device_info.company = company, device_info.customer = customer, device_info.email = email, device_info.zip = zip, device_info.address = address,
      device_info.phone1 = phone1, device_info.phone2 = phone2, device_info.fax = fax, device_info.`mid` = `mid`, device_info.mpass = mpass,
      device_info.memo1 = memo1, device_info.memo2 = memo2, device_info.code1 = code1, device_info.code2 = code2
      WHERE device_info.device_id = overwrited_id;

      IF cur_state THEN
        ROLLBACK;
        SELECT 0 as col, id as col2;
      ELSE
        UPDATE snmp_info SET snmp_info.version = version, snmp_info.community = community, snmp_info.use_inherit = use_inherit, snmp_info.`level` = `level`,
        snmp_info.`user` = `user`, snmp_info.authprot = authprot, snmp_info.authpass = authpass, snmp_info.privprot = privprot, snmp_info.privpass = privpass
        WHERE snmp_info.device_id = overwrited_id;

        IF cur_state THEN
          ROLLBACK;
          SELECT 0 as col, id as col2;
        ELSE
          COMMIT;
          SELECT 1 as col, overwrited_id as col2;
        END IF;
      END IF;
    END IF;
  END;
END


***** setDeviceInfo *****
CREATE DEFINER=`sesm`@`%` PROCEDURE `setDeviceInfo`(
  IN id INT, IN name VARCHAR(128),
  IN `desc` VARCHAR(255), IN ip VARCHAR(32),
  IN active INT, IN log INT, IN alarm INT,
  IN serial VARCHAR(255), IN company VARCHAR(255), IN customer VARCHAR(255),
  IN email VARCHAR(255), IN zip VARCHAR(255),
  IN address VARCHAR(255), IN phone1 VARCHAR(255),
  IN phone2 VARCHAR(255), IN fax VARCHAR(255),
  IN `mid` VARCHAR(255), IN mpass VARCHAR(255),
  IN gid INT, IN product_id INT,
  IN use_inherit INT,
  IN version VARCHAR(32), IN community VARCHAR(128),
  IN `level` VARCHAR(32), IN `user` VARCHAR(128),
  IN authprot VARCHAR(128), IN authpass VARCHAR(128),
  IN privprot VARCHAR(32), IN privpass VARCHAR(128),
  IN memo1 VARCHAR(255), IN memo2 VARCHAR(255),
  IN code1 VARCHAR(32), IN code2 VARCHAR(32)
)
BEGIN
  -- 장비 정보 업데이트
  DECLARE cur_state INT DEFAULT '0';
  DECLARE select_id INT DEFAULT '0';
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET cur_state = 1;
  DECLARE CONTINUE HANDLER FOR SQLWARNING  SET cur_state = 1;
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET cur_state = 1;

  START TRANSACTION;

  -- 0, 0 을 리턴할 경우 장비 추가 및 수정 실패하고 원인은 중복 시리얼이 있는 경우입니다.
  -- 0, device_id 를 리턴할 경우 장비 추가 및 수정 실패하고 원인은 중복 장비명이 있는 경우입니다.
  -- 1, device_id 를 리턴할 경우 장비 추가 및 수정 성공하고 device_id 는 추가 또는 수정된 장비의 id 입니다.
  SET_DEVICEINFO:
  BEGIN
    -- 동일한 시리얼을 가진 장비가 있는지 조회
    SELECT di.device_id, d.candidate INTO @id_var, @candi_var FROM device_info di, device d WHERE di.device_id = d.id AND di.serial = serial;

    IF id IS NULL THEN
      -- 신규 추가 인데 동일한 시리얼 장비가 이미 리스트에 있다면 미등록 상태인지 확인.
      IF @candi_var = 0 THEN
        SELECT 0 as col, 0 as col2;
        # 프로시저 종료
        LEAVE SET_DEVICEINFO;
      END IF;
    ELSE
      -- 수정인데 동일한 시리얼 장비가 다른 id를 가지고 있으면 안됨.
      IF @id_var != id THEN
        SELECT 0 as col, 0 as col2;
        # 프로시저 종료
        LEAVE SET_DEVICEINFO;
      END IF;
      SET @id_var = id;
    END IF;

    SET cur_state = 0;

    IF @id_var IS NULL THEN
      SET select_id = NULL;
    ELSE
      SET select_id = @id_var;
    END IF;

    -- 장비 기본 정보 설정
    INSERT INTO device (id, name, `desc`, ip, active, log, alarm, product_id, group_id)
    VALUES (select_id, name, `desc`, ip, active, log, alarm, product_id, gid)
    ON DUPLICATE KEY UPDATE device.name = name, device.desc=`desc`, device.ip = ip, device.active = active, device.log = log,
    device.alarm = alarm, device.product_id = product_id, device.group_id = gid;

    IF cur_state THEN
      ROLLBACK;
      SELECT 0 as col, select_id as col2;
    ELSE
      IF select_id IS NULL THEN
        SELECT LAST_INSERT_ID() INTO select_id;
      END IF;

      UPDATE device SET candidate = 0 WHERE device.id = select_id;

      IF select_id = gid THEN
        SET cur_state = 2;
      END IF;

      IF cur_state THEN
        ROLLBACK;
        SELECT 0 as col, select_id  as col2;
      ELSE
        -- 장비 세부 정보 설정
        INSERT INTO device_info (device_id, serial, company, customer, email, zip, address, phone1, phone2, fax, `mid`, mpass, memo1, memo2, code1, code2)
        VALUES (select_id, serial, company, customer, email, zip, address, phone1, phone2, fax, `mid`, mpass, memo1, memo2, code1, code2)
        ON DUPLICATE KEY UPDATE
        device_info.serial = serial, device_info.company = company, device_info.customer = customer, device_info.email = email, device_info.zip = zip, device_info.address = address,
        device_info.phone1 = phone1, device_info.phone2 = phone2, device_info.fax = fax, device_info.`mid` = `mid`, device_info.mpass = mpass,
        device_info.memo1 = memo1, device_info.memo2 = memo2, device_info.code1 = code1, device_info.code2 = code2;

        IF cur_state THEN
          ROLLBACK;
          SELECT 0 as col, select_id  as col2;
        ELSE
          -- 개별 장비 snmp 정보 설정
         INSERT INTO snmp_info (device_id, use_inherit, version, community, `level`, `user`, authprot, authpass, privprot, privpass)
          VALUES (select_id, use_inherit, version, community, `level`, `user`, authprot, authpass, privprot, privpass)
          ON DUPLICATE KEY UPDATE snmp_info.version = version, snmp_info.community = community, snmp_info.use_inherit = use_inherit, snmp_info.`level` = `level`,
          snmp_info.`user` = `user`, snmp_info.authprot = authprot, snmp_info.authpass = authpass, snmp_info.privprot = privprot, snmp_info.privpass = privpass;

          IF cur_state THEN
            ROLLBACK;
            SELECT 0 as col, select_id as col2;
          ELSE
            COMMIT;
            SELECT 1 as col, select_id as col2;
          END IF;
        END IF;
      END IF;
    END IF;
  END;
END


***** getIntegrityInfoList *****
CREATE DEFINER=`sesm`@`%` PROCEDURE `getIntegrityInfoList`(IN skip VARCHAR(8), IN limits VARCHAR(8))
BEGIN
  -- 무결성 정보 조회 (ESM)
  DECLARE strLimit VARCHAR(32);
  SET strLimit = '';

  IF (NULLIF(skip, '') IS NOT NULL) AND (NULLIF(limits, '') IS NOT NULL) THEN
    SET strLimit = CONCAT(strLimit, ' LIMIT ', skip, ',', limits);
  END IF;

  SET @Total = (SELECT COUNT(*) FROM sesm.integrity);

  SET @query = CONCAT("SELECT id, item, size, mdate, cdate, status, checksum, ", @Total, " as total FROM integrity ", strLimit);
  PREPARE stmt FROM @query;
  EXECUTE stmt;
  DEALLOCATE PREPARE stmt;

END


***** setLogDiskInfo *****
CREATE DEFINER=`sesm`@`%` PROCEDURE `setLogDiskInfo`(IN logdisk_delete VARCHAR(255), IN logdisk_warn VARCHAR(255))
BEGIN
  -- 로그 디스크 임계치 정보 설정 (경보, 삭제)
  DECLARE cur_state INT DEFAULT '0';
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET cur_state = 1;
  DECLARE CONTINUE HANDLER FOR SQLWARNING  SET cur_state = 2;
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET cur_state = 3;

  START TRANSACTION;

  UPDATE config SET val=logdisk_delete WHERE attr='logdisk_delete';
  UPDATE config SET val=logdisk_warn WHERE attr='logdisk_warn';

  IF cur_state THEN
    ROLLBACK;
    SELECT 0 as col;
  ELSE
    COMMIT;
    SELECT 1 as col;
  END IF;
END


***** setInterfaceConfig *****
CREATE DEFINER=`sesm`@`%` PROCEDURE `setInterfaceConfig`(
  IN interface_downtime VARCHAR(255),
  IN interface_updown_count VARCHAR(255),
  IN interface_updown_hours VARCHAR(255))
BEGIN
  -- 회선 관리 정보 설정
  DECLARE cur_state INT DEFAULT '0';
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET cur_state = 1;
  DECLARE CONTINUE HANDLER FOR SQLWARNING  SET cur_state = 2;
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET cur_state = 3;

  START TRANSACTION;

  UPDATE config SET val=interface_downtime WHERE attr='interface_downtime';
  UPDATE config SET val=interface_updown_count WHERE attr='interface_updown_count';
  UPDATE config SET val=interface_updown_hours WHERE attr='interface_updown_hours';

  IF cur_state THEN
    ROLLBACK;
    SELECT 0 as col;
  ELSE
    COMMIT;
    SELECT 1 as col;
  END IF;
END

***** getDeviceInfoList *****
CREATE DEFINER=`sesm`@`%` PROCEDURE `getDeviceInfoList`(
  IN ids VARCHAR(2048))
BEGIN
  -- 장비 정보 조회
  DECLARE strWhere VARCHAR(3072);
  SET strWhere = '';

  IF NULLIF(ids, '') IS NOT NULL AND ids != '0' THEN
    SET strWhere = CONCAT(strWhere, ' AND FIND_IN_SET(d.id, "', ids, '")');
  ELSEIF NULLIF(ids, '') IS NULL THEN
    SET strWhere = CONCAT(strWhere, ' AND FIND_IN_SET(d.id, "0")');
  END IF;

  SET @query = CONCAT("SELECT d.id, d.name as dn, d.`desc`, d.ip, p.id as product_id, dg.id as pGroupID, dg.name as gn,
    di.serial, di.os, di.agent, di.hostname, di.company, di.customer, di.email, di.zip,
    di.address, di.phone1, di.phone2, di.fax, di.mid, p.type
    FROM device_info di, device_group dg, product p, device d, snmp_info si
    WHERE d.candidate = 0 AND di.device_id = d.id AND dg.id = d.group_id AND p.id = d.product_id AND d.id = si.device_id ", strWhere);
  PREPARE stmt3 FROM @query;
  EXECUTE stmt3;
END

***** setAlarmInfo *****
CREATE DEFINER=`sesm`@`%` PROCEDURE `setAlarmInfo`(
  IN id INT, IN use_alarm INT ,
  IN email VARCHAR(255), IN use_inherit INT,
  IN cpu INT, IN mem INT,
  IN disk0 INT, IN disk1 INT,
  IN session INT, IN host INT, IN tunnel INT, IN cps INT,
  IN rbytes INT, IN tbytes INT,
  IN rpkts INT, IN tpkts INT,
  IN rtt INT)
BEGIN
  -- 장비 또는 장비 그룹의 임계치 설정
  DECLARE cur_state INT DEFAULT '0';
  DECLARE select_id INT DEFAULT '0';
  DECLARE ids varchar(1024);
  DECLARE alarm_id int DEFAULT 0;

  DECLARE current_lv int UNSIGNED;
  DECLARE parent_ids varchar(10000);
  DECLARE child_ids varchar(10000);
  DECLARE cnt int DEFAULT 0;
  DECLARE before_cnt int DEFAULT 0;
  DECLARE inherit int DEFAULT 0;

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET cur_state = 1;
  DECLARE CONTINUE HANDLER FOR SQLWARNING  SET cur_state = 1;
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET cur_state = 1;

  SET ids = '';

  SET SESSION sql_log_bin = OFF;
  SET SESSION tx_isolation = 'READ-COMMITTED';
  SET @_current_lv := 1;

  START TRANSACTION;

  -- alarm_config 테이블에 설정한 임계치 값 업데이트
  INSERT INTO alarm_config VALUES (id, use_alarm, email, use_inherit, cpu, mem, disk0, disk1, session, host, tunnel, cps, rbytes, tbytes, rpkts, tpkts, rtt)
    ON DUPLICATE KEY UPDATE alarm_config.use_alarm=use_alarm, alarm_config.email=email, alarm_config.use_inherit=use_inherit,
    alarm_config.cpu=cpu, alarm_config.mem=mem, alarm_config.disk0=disk0, alarm_config.disk1=disk1, alarm_config.session=session,
    alarm_config.host=host, alarm_config.tunnel=tunnel, alarm_config.cps=cps,
    alarm_config.rbytes=rbytes, alarm_config.tbytes=tbytes, alarm_config.rpkts=rpkts, alarm_config.tpkts=tpkts, alarm_config.rtt=rtt;


  IF id IS NULL THEN
    SELECT LAST_INSERT_ID() INTO select_id;
  ELSE
    SET select_id = id;
  END IF;

  -- 장비 그룹의 임계치 설정인지 장비의 임계치 설정인지 확인
  SELECT COUNT(*) INTO @gr_cnt FROM device_group WHERE device_group.id = select_id;

  -- 그룹 설정인 경우
  IF @gr_cnt > 0 THEN
    -- 하위 그룹 리스트 중 상위 그룹 설정을 따름으로 설정되어 있거나
    -- 하위 그룹 리스트 중 기본 설정을 따름으로 설정되어 있는 그룹 조회
    drop table if exists _temp_buffer;
    CREATE TEMPORARY TABLE IF NOT EXISTS _temp_buffer (
      id int(11),
      name varchar(255),
      group_id int(11),
      lv int,
      INDEX ix_lv (lv)
      ) ENGINE = MEMORY;

    IF select_id = 0 THEN
      INSERT INTO _temp_buffer SELECT dg.id, dg.name, dg.group_id, @_current_lv AS lv
        FROM device_group dg, alarm_config ac
        WHERE ac.id = dg.id AND ac.use_inherit = 0 GROUP BY dg.id;
    ELSE
      INSERT INTO _temp_buffer SELECT dg.id, dg.name, dg.group_id, @_current_lv AS lv
        FROM device_group dg, alarm_config ac
        WHERE dg.id = select_id AND ac.id = dg.id;
    END IF;

    recursion:
    REPEAT
      SET before_cnt = cnt;
      SELECT GROUP_CONCAT(_temp_buffer.id), COUNT(*) INTO parent_ids, cnt FROM _temp_buffer WHERE lv = @_current_lv;

      IF cnt = 0 THEN
        LEAVE recursion;
      END IF;

      IF select_id = 0 THEN
        SET @query = CONCAT("INSERT INTO _temp_buffer
          SELECT dg.id, dg.name, dg.group_id, (@_current_lv + 1) AS lv
          FROM device_group dg, alarm_config ac WHERE (dg.id <> dg.group_id) AND dg.group_id IN (", parent_ids, ") AND (ac.use_inherit = 1 OR ac.use_inherit = 0) AND ac.id = dg.id");
        PREPARE stmt3 FROM @query;
        EXECUTE stmt3;
      ELSE
        SET @query = CONCAT("INSERT INTO _temp_buffer
          SELECT dg.id, dg.name, dg.group_id, (@_current_lv + 1) AS lv
          FROM device_group dg, alarm_config ac WHERE dg.group_id IN (", parent_ids, ") AND ac.use_inherit = 1 AND ac.id = dg.id");
        PREPARE stmt3 FROM @query;
        EXECUTE stmt3;
      END IF;

      SET @_current_lv = @_current_lv + 1;
    UNTIL 0 END REPEAT;

    -- 자신을 포함한 하위 그룹 리스트 = child_ids
    SELECT GROUP_CONCAT(DISTINCT _temp_buffer.id) INTO child_ids FROM _temp_buffer;

    SET cur_state = 0;
    SET inherit = 1;
    SET ids = child_ids;

    -- 기본 설정이 변경된 경우
    IF select_id = 0 THEN
      IF ids IS NOT NULL AND ids != "" THEN
        SET @query= CONCAT("UPDATE alarm_config as ac1, alarm_config as ac2, device_group as dg
          SET ac1.cpu=ac2.cpu, ac1.mem=ac2.mem, ac1.disk0=ac2.disk0, ac1.disk1=ac2.disk1, ac1.session=ac2.session, ac1.host=ac2.host, ac1.tunnel=ac2.tunnel, ac1.cps=ac2.cps,
          ac1.rbytes=ac2.rbytes, ac1.tbytes=ac2.tbytes, ac1.rpkts=ac2.rpkts, ac1.tpkts=ac2.tpkts, ac1.rtt=ac2.rtt
          WHERE dg.id IN (", ids, ") AND dg.id = ac1.id AND ac2.id = 0");
        PREPARE stmt3 FROM @query;
        EXECUTE stmt3;

        -- 기본 설정을 상속받는 그룹들중 그룹에 속한 장비가 상위 그룹 설정으로 되어 있는 경우 임계치 업데이트
        SET @query= CONCAT("UPDATE alarm_config as ac1, alarm_config as ac2, device as d
          SET ac1.cpu=ac2.cpu, ac1.mem=ac2.mem, ac1.disk0=ac2.disk0, ac1.disk1=ac2.disk1, ac1.session=ac2.session, ac1.host=ac2.host, ac1.tunnel=ac2.tunnel, ac1.cps=ac2.cps,
          ac1.rbytes=ac2.rbytes, ac1.tbytes=ac2.tbytes, ac1.rpkts=ac2.rpkts, ac1.tpkts=ac2.tpkts, ac1.rtt=ac2.rtt
          WHERE d.group_id IN (", ids, ") AND d.id = ac1.id AND ac1.use_inherit = 1 AND ac2.id = 0");
        PREPARE stmt3 FROM @query;
        EXECUTE stmt3;
      END IF;

      -- 기본 설정을 사용하는 장비의 임계치 업데이트
      UPDATE alarm_config as ac1, alarm_config as ac2
        SET ac1.cpu=ac2.cpu, ac1.mem=ac2.mem, ac1.disk0=ac2.disk0, ac1.disk1=ac2.disk1, ac1.session=ac2.session, ac1.host=ac2.host, ac1.tunnel=ac2.tunnel, ac1.cps=ac2.cps,
        ac1.rbytes=ac2.rbytes, ac1.tbytes=ac2.tbytes, ac1.rpkts=ac2.rpkts, ac1.tpkts=ac2.tpkts, ac1.rtt=ac2.rtt
        WHERE ac1.use_inherit = 0 AND ac2.id = 0;

    -- 그룹 설정이 변경된 경우
    -- 기본 설정을 따름으로 설정이 변경된 경우
    ELSEIF use_inherit = 0 THEN
      SET @query= CONCAT("UPDATE alarm_config as ac1, alarm_config as ac2
        SET ac1.cpu=ac2.cpu, ac1.mem=ac2.mem, ac1.disk0=ac2.disk0, ac1.disk1=ac2.disk1, ac1.session=ac2.session, ac1.host=ac2.host, ac1.tunnel=ac2.tunnel, ac1.cps=ac2.cps,
        ac1.rbytes=ac2.rbytes, ac1.tbytes=ac2.tbytes, ac1.rpkts=ac2.rpkts, ac1.tpkts=ac2.tpkts, ac1.rtt=ac2.rtt
        WHERE ac1.id = ", select_id, " AND ac2.id = 0");
      PREPARE stmt3 FROM @query;
      EXECUTE stmt3;

      -- 하위 그룹들 중 상위 그룹 설정을 따름으로 설정되어 있는 장비 임계치 업데이트
      IF ids IS NOT NULL AND ids != "" THEN
        SET @query= CONCAT("UPDATE alarm_config as ac1, alarm_config as ac2, device_group as dg
          SET ac1.cpu=ac2.cpu, ac1.mem=ac2.mem, ac1.disk0=ac2.disk0, ac1.disk1=ac2.disk1, ac1.session=ac2.session, ac1.host=ac2.host, ac1.tunnel=ac2.tunnel, ac1.cps=ac2.cps,
          ac1.rbytes=ac2.rbytes, ac1.tbytes=ac2.tbytes, ac1.rpkts=ac2.rpkts, ac1.tpkts=ac2.tpkts, ac1.rtt=ac2.rtt
          WHERE dg.id IN (", ids, ") AND ac1.use_inherit = 1 AND dg.id = ac1.id AND ac2.id = 0");
        PREPARE stmt3 FROM @query;
        EXECUTE stmt3;

        SET @query= CONCAT("UPDATE alarm_config as ac1, alarm_config as ac2, device as d
          SET ac1.cpu=ac2.cpu, ac1.mem=ac2.mem, ac1.disk0=ac2.disk0, ac1.disk1=ac2.disk1, ac1.session=ac2.session, ac1.host=ac2.host, ac1.tunnel=ac2.tunnel, ac1.cps=ac2.cps,
          ac1.rbytes=ac2.rbytes, ac1.tbytes=ac2.tbytes, ac1.rpkts=ac2.rpkts, ac1.tpkts=ac2.tpkts, ac1.rtt=ac2.rtt
          WHERE d.group_id IN (", ids, ") AND d.id = ac1.id AND ac1.use_inherit = 1 AND ac2.id = 0");
        PREPARE stmt3 FROM @query;
        EXECUTE stmt3;
      END IF;
    -- 상위 그룹 설정을 따름으로 설정이 변경된 경우
    ELSEIF use_inherit = 1 THEN
      SELECT dg.group_id INTO @pgroup FROM device_group dg WHERE dg.id = select_id;

      IF ids IS NOT NULL AND ids != "" THEN
        SET @query= CONCAT("UPDATE alarm_config as ac1, alarm_config as ac2, device_group as dg
          SET ac1.cpu=ac2.cpu, ac1.mem=ac2.mem, ac1.disk0=ac2.disk0, ac1.disk1=ac2.disk1, ac1.session=ac2.session, ac1.host=ac2.host, ac1.tunnel=ac2.tunnel, ac1.cps=ac2.cps,
          ac1.rbytes=ac2.rbytes, ac1.tbytes=ac2.tbytes, ac1.rpkts=ac2.rpkts, ac1.tpkts=ac2.tpkts, ac1.rtt=ac2.rtt
          WHERE dg.id IN (", ids, ") AND ac1.use_inherit = 1 AND dg.id = ac1.id AND ac2.id = @pgroup");
        PREPARE stmt3 FROM @query;
        EXECUTE stmt3;

        SET @query= CONCAT("UPDATE alarm_config as ac1, alarm_config as ac2, device_group dg
          SET ac1.cpu=ac2.cpu, ac1.mem=ac2.mem, ac1.disk0=ac2.disk0, ac1.disk1=ac2.disk1, ac1.session=ac2.session, ac1.host=ac2.host, ac1.tunnel=ac2.tunnel, ac1.cps=ac2.cps,
          ac1.rbytes=ac2.rbytes, ac1.tbytes=ac2.tbytes, ac1.rpkts=ac2.rpkts, ac1.tpkts=ac2.tpkts, ac1.rtt=ac2.rtt
          WHERE ac1.id IN (", ids, ") AND ac1.use_inherit = 1 AND ac2.id = @pgroup");
        PREPARE stmt3 FROM @query;
        EXECUTE stmt3;

        SET @query= CONCAT("UPDATE alarm_config as ac1, alarm_config as ac2, device d
          SET ac1.cpu=ac2.cpu, ac1.mem=ac2.mem, ac1.disk0=ac2.disk0, ac1.disk1=ac2.disk1, ac1.session=ac2.session, ac1.host=ac2.host, ac1.tunnel=ac2.tunnel, ac1.cps=ac2.cps,
          ac1.rbytes=ac2.rbytes, ac1.tbytes=ac2.tbytes, ac1.rpkts=ac2.rpkts, ac1.tpkts=ac2.tpkts, ac1.rtt=ac2.rtt
          WHERE ac1.id = d.id AND ac1.use_inherit = 1 AND ac2.id = @pgroup AND d.group_id IN (", ids, ")");
        PREPARE stmt3 FROM @query;
        EXECUTE stmt3;
      END IF;

    -- 장비 그룹 개별설정이 변경된 경우
    ELSE
      IF ids IS NOT NULL AND ids != "" THEN
        SET @query= CONCAT("UPDATE alarm_config as ac1, alarm_config as ac2, device_group as dg
          SET ac1.cpu=ac2.cpu, ac1.mem=ac2.mem, ac1.disk0=ac2.disk0, ac1.disk1=ac2.disk1, ac1.session=ac2.session, ac1.host=ac2.host, ac1.tunnel=ac2.tunnel, ac1.cps=ac2.cps,
          ac1.rbytes=ac2.rbytes, ac1.tbytes=ac2.tbytes, ac1.rpkts=ac2.rpkts, ac1.tpkts=ac2.tpkts, ac1.rtt=ac2.rtt
          WHERE dg.id IN (", ids, ") AND ac1.use_inherit = 1 AND dg.id = ac1.id AND ac2.id = ", select_id);
        PREPARE stmt3 FROM @query;
        EXECUTE stmt3;

        SET @query= CONCAT("UPDATE alarm_config as ac1, alarm_config as ac2, device as d
          SET ac1.cpu=ac2.cpu, ac1.mem=ac2.mem, ac1.disk0=ac2.disk0, ac1.disk1=ac2.disk1, ac1.session=ac2.session, ac1.host=ac2.host, ac1.tunnel=ac2.tunnel, ac1.cps=ac2.cps,
          ac1.rbytes=ac2.rbytes, ac1.tbytes=ac2.tbytes, ac1.rpkts=ac2.rpkts, ac1.tpkts=ac2.tpkts, ac1.rtt=ac2.rtt
          WHERE d.group_id IN (", ids, ") AND d.id = ac1.id AND ac1.use_inherit = 1 AND ac2.id = ", select_id);
        PREPARE stmt3 FROM @query;
        EXECUTE stmt3;
      END IF;

    END IF;

  -- 장비 설정
  ELSE
    -- 기본 설정 따름
    IF use_inherit = 0 THEN
      UPDATE alarm_config as ac1, alarm_config as ac2
        SET ac1.cpu=ac2.cpu, ac1.mem=ac2.mem, ac1.disk0=ac2.disk0, ac1.disk1=ac2.disk1, ac1.session=ac2.session, ac1.host=ac2.host, ac1.tunnel=ac2.tunnel, ac1.cps=ac2.cps,
        ac1.rbytes=ac2.rbytes, ac1.tbytes=ac2.tbytes, ac1.rpkts=ac2.rpkts, ac1.tpkts=ac2.tpkts, ac1.rtt=ac2.rtt
        WHERE ac1.id = select_id AND ac2.id = 0;
    -- 상위 그룹 설정 따름
    ELSEIF use_inherit = 1 THEN
      SELECT d.group_id INTO @pgroup FROM device d WHERE d.id = select_id;
      UPDATE alarm_config as ac1, alarm_config as ac2, device_group dg
        SET ac1.cpu=ac2.cpu, ac1.mem=ac2.mem, ac1.disk0=ac2.disk0, ac1.disk1=ac2.disk1, ac1.session=ac2.session, ac1.host=ac2.host, ac1.tunnel=ac2.tunnel, ac1.cps=ac2.cps,
        ac1.rbytes=ac2.rbytes, ac1.tbytes=ac2.tbytes, ac1.rpkts=ac2.rpkts, ac1.tpkts=ac2.tpkts, ac1.rtt=ac2.rtt
        WHERE ac1.id = select_id AND ac2.id = @pgroup;
    END IF;
  END IF;

  IF cur_state THEN
    ROLLBACK;
    SELECT 0 as col;
  ELSE
    COMMIT;
    SELECT 1 as col;
  END IF;

  TRUNCATE TABLE _temp_buffer;
  SET SESSION sql_log_bin = ON;
  SET SESSION tx_isolation = 'REPEATABLE-READ';
END